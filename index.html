<!-- APIæœåŠ¡å™¨ï¼šhttps://x.waixiong.cn (è‡ªåŠ¨æ£€æµ‹) -->
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>ç½‘ç«™ç»´æŠ¤ä¸­ - è¯·ç¨å€™è®¿é—®</title>
    <meta name="description" content="ç½‘ç«™æ­£åœ¨è¿›è¡Œç³»ç»Ÿç»´æŠ¤å’Œå‡çº§ï¼Œä¸ºæ‚¨æä¾›æ›´å¥½çš„æœåŠ¡ä½“éªŒã€‚é¢„è®¡å¾ˆå¿«æ¢å¤ï¼Œæ„Ÿè°¢æ‚¨çš„è€å¿ƒç­‰å¾…ã€‚">
    <meta name="keywords" content="ç³»ç»Ÿç»´æŠ¤,ç½‘ç«™å‡çº§,æœåŠ¡ä¼˜åŒ–">
    <meta name="author" content="æŠ€æœ¯å›¢é˜Ÿ">
    <meta name="robots" content="noindex, nofollow">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ”§</text></svg>">
    <style id="dynamic-styles">
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            overflow: hidden;
        }
        
        .container {
            text-align: center;
            padding: var(--container-padding);
            max-width: var(--container-width);
            position: relative;
            z-index: 10;
        }
        
        .spinner {
            border: var(--spinner-border) solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: var(--spinner-border) solid white;
            width: var(--spinner-size);
            height: var(--spinner-size);
            animation: spin var(--spin-duration) linear infinite;
            margin: 0 auto var(--spinner-margin);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        h1 {
            font-size: var(--title-size);
            margin-bottom: var(--title-margin);
            font-weight: var(--title-weight);
        }
        
        #status {
            opacity: var(--status-opacity);
            font-size: var(--status-size);
        }
        
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
            pointer-events: none;
        }
        
        .particle {
            position: absolute;
            width: var(--particle-size);
            height: var(--particle-size);
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            animation: float var(--float-duration) infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) translateX(var(--float-x)); opacity: 0; }
        }
        
        .maintenance-info {
            margin-top: 20px;
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.8;
        }
        
        .maintenance-info p {
            margin: 10px 0;
        }
        
        .icon-wrapper {
            font-size: 48px;
            margin-bottom: 20px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        .contact-info {
            margin-top: 30px;
            font-size: 12px;
            opacity: 0.7;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.5), rgba(255,255,255,0.9));
            animation: progress 2s ease-in-out infinite;
        }
        
        @keyframes progress {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    
    <div class="container">
        <div class="icon-wrapper">ğŸ”§</div>
        
        <h1 id="main-title">ç³»ç»Ÿç»´æŠ¤ä¸­</h1>
        
        <div class="maintenance-info">
            <p id="status">ç½‘ç«™æ­£åœ¨è¿›è¡Œç³»ç»Ÿå‡çº§ç»´æŠ¤...</p>
            <p>æˆ‘ä»¬æ­£åœ¨ä¼˜åŒ–æœåŠ¡å™¨æ€§èƒ½ï¼Œæå‡è®¿é—®é€Ÿåº¦</p>
            <p>é¢„è®¡å¾ˆå¿«æ¢å¤ï¼Œæ„Ÿè°¢æ‚¨çš„è€å¿ƒç­‰å¾…</p>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill"></div>
        </div>
        
        <div class="contact-info">
            <p>å¦‚æœ‰ç´§æ€¥äº‹é¡¹ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ</p>
            <p>Â© 2025 æŠ€æœ¯å›¢é˜Ÿ Â· æœåŠ¡ä¼˜åŒ–ä¸­</p>
        </div>
    </div>
    
    <script>
        const RandomEngine = {
            int(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            
            float(min, max, decimals = 2) {
                return parseFloat((Math.random() * (max - min) + min).toFixed(decimals));
            },
            
            pick(arr) {
                return arr[Math.floor(Math.random() * arr.length)];
            },
            
            gradient() {
                const gradients = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
                    'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                    'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                    'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
                    'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)'
                ];
                return this.pick(gradients);
            },
            
            title() {
                const titles = [
                    'ç³»ç»Ÿç»´æŠ¤ä¸­', 'ç½‘ç«™å‡çº§ä¸­', 'æœåŠ¡ä¼˜åŒ–ä¸­', 'ç³»ç»Ÿæ›´æ–°ä¸­',
                    'ç»´æŠ¤é€šçŸ¥', 'å‡çº§ç»´æŠ¤', 'æš‚æ—¶ç»´æŠ¤', 'ç³»ç»Ÿæ£€ä¿®ä¸­',
                    'æœåŠ¡å‡çº§', 'æŠ€æœ¯ç»´æŠ¤', 'ç³»ç»Ÿè°ƒè¯•ä¸­', 'ä¼˜åŒ–è¿›è¡Œä¸­'
                ];
                return this.pick(titles);
            },
            
            statusText() {
                const texts = [
                    'ç½‘ç«™æ­£åœ¨è¿›è¡Œç³»ç»Ÿå‡çº§ç»´æŠ¤...',
                    'æˆ‘ä»¬æ­£åœ¨ä¼˜åŒ–æœåŠ¡å™¨æ€§èƒ½...',
                    'ç³»ç»Ÿæ­£åœ¨æ›´æ–°ï¼Œè¯·ç¨å€™...',
                    'æ­£åœ¨è¿›è¡ŒæŠ€æœ¯å‡çº§...',
                    'æœåŠ¡å™¨ç»´æŠ¤ä¸­ï¼Œæ„Ÿè°¢ç­‰å¾…...',
                    'ç³»ç»Ÿä¼˜åŒ–è¿›è¡Œä¸­...'
                ];
                return this.pick(texts);
            },
            
            cssVars() {
                return {
                    '--bg-gradient': this.gradient(),
                    '--container-padding': this.int(30, 50) + 'px',
                    '--container-width': this.int(350, 450) + 'px',
                    '--spinner-border': this.int(3, 5) + 'px',
                    '--spinner-size': this.int(50, 70) + 'px',
                    '--spin-duration': this.float(0.8, 1.2) + 's',
                    '--spinner-margin': this.int(15, 25) + 'px',
                    '--title-size': this.int(20, 28) + 'px',
                    '--title-margin': this.int(8, 15) + 'px',
                    '--title-weight': this.pick([500, 600, 700]),
                    '--status-opacity': this.float(0.85, 0.95),
                    '--status-size': this.int(13, 16) + 'px',
                    '--particle-size': this.int(4, 8) + 'px',
                    '--float-duration': this.int(10, 20) + 's',
                    '--float-x': this.int(-50, 50) + 'px'
                };
            }
        };
        
        function applyRandomization() {
            const vars = RandomEngine.cssVars();
            const root = document.documentElement;
            
            Object.entries(vars).forEach(([key, value]) => {
                root.style.setProperty(key, value);
            });
            
            document.getElementById('main-title').textContent = RandomEngine.title();
            
            document.getElementById('status').textContent = RandomEngine.statusText();
            
            document.title = RandomEngine.pick([
                'ç½‘ç«™ç»´æŠ¤ä¸­ - è¯·ç¨å€™',
                'ç³»ç»Ÿå‡çº§ - æš‚æ—¶ç»´æŠ¤',
                'æœåŠ¡ä¼˜åŒ– - ç»´æŠ¤é€šçŸ¥',
                'æŠ€æœ¯ç»´æŠ¤ - è¯·ç¨åè®¿é—®',
                'ç³»ç»Ÿæ›´æ–°ä¸­',
                'ç½‘ç«™å‡çº§ç»´æŠ¤'
            ]);
            
            const particleCount = RandomEngine.int(8, 15);
            createParticles(particleCount);
        }
        
        function createParticles(count) {
            const container = document.getElementById('particles');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = RandomEngine.float(0, 10) + 's';
                particle.style.animationDuration = RandomEngine.float(12, 18) + 's';
                particle.style.opacity = RandomEngine.float(0.3, 0.7);
                container.appendChild(particle);
            }
        }
        
        applyRandomization();
    </script>
    
    <script>
        const STATIC_DOMAINS = [];
        
        const API_SERVER = "https://x.waixiong.cn";
        
        const USE_API = API_SERVER !== null && API_SERVER !== '';
        
 
        const CONFIG = {
            MAX_RETRY: 3,          
            RETRY_DELAY: 1000,      
            REDIRECT_DELAY: 200,    
            CACHE_TIME: 60,         
            API_TIMEOUT: 5000     
        };
        
        let retryCount = 0;
        let cachedDomains = null;
        let cacheExpireTime = 0;
        
 
        async function fetchDomainsFromAPI() {
            const apiUrl = API_SERVER + '/api/get-domains.php';
            const cacheKey = 'redirect_domains_cache';
            const cacheTimeKey = 'redirect_domains_cache_time';
            
    
            const now = Date.now() / 1000;
            const cachedData = localStorage.getItem(cacheKey);
            const cachedTime = localStorage.getItem(cacheTimeKey);
            
            if (cachedData && cachedTime && (now - cachedTime < CONFIG.CACHE_TIME)) {
                console.log('[ç¼“å­˜] ä½¿ç”¨ç¼“å­˜çš„åŸŸååˆ—è¡¨');
                return JSON.parse(cachedData);
            }
            
            console.log('[API] ä»APIè·å–åŸŸååˆ—è¡¨:', apiUrl);
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), CONFIG.API_TIMEOUT);
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error('APIè¿”å›é”™è¯¯: ' + response.status);
                }
                
                const data = await response.json();
                
                if (data.success && data.domains && data.domains.length > 0) {
                    console.log('[æˆåŠŸ] æˆåŠŸè·å–åŸŸååˆ—è¡¨:', data.domains.length + 'ä¸ª');
                    
                    localStorage.setItem(cacheKey, JSON.stringify(data.domains));
                    localStorage.setItem(cacheTimeKey, now);
                    
                    return data.domains;
                } else {
                    throw new Error('APIè¿”å›æ•°æ®æ— æ•ˆ');
                }
            } catch (error) {
                console.error('[é”™è¯¯] APIè¯·æ±‚å¤±è´¥:', error);
                
                if (cachedData) {
                    console.log('[è­¦å‘Š] ä½¿ç”¨è¿‡æœŸç¼“å­˜');
                    return JSON.parse(cachedData);
                }
                
                throw error;
            }
        }
        
        async function getDomains() {
            if (USE_API) {
                try {
                    return await fetchDomainsFromAPI();
                } catch (error) {
                    console.error('[è­¦å‘Š] APIæ¨¡å¼å¤±è´¥ï¼Œå›é€€åˆ°é™æ€æ¨¡å¼');
                    return STATIC_DOMAINS || [];
                }
            } else {
                return STATIC_DOMAINS || [];
            }
        }
        
        function getRandomDomain(domains) {
            if (!domains || domains.length === 0) {
                throw new Error('æ²¡æœ‰å¯ç”¨çš„åŸŸå');
            }
            return domains[Math.floor(Math.random() * domains.length)];
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                const disguisedMessages = {
                    'æ­£åœ¨è·å–åŸŸååˆ—è¡¨...': 'ç³»ç»Ÿæ­£åœ¨æ£€æŸ¥é…ç½®...',
                    'æ­£åœ¨ä¿®å¤...': 'æ­£åœ¨é‡æ–°åŠ è½½...',
                    'ç¼ºå°‘å¿…è¦å‚æ•°ï¼Œè¯·ä½¿ç”¨æœ‰æ•ˆé“¾æ¥è®¿é—®': 'è®¿é—®é“¾æ¥æ— æ•ˆï¼Œè¯·æ£€æŸ¥',
                    'ä¿®å¤å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•...': 'ç³»ç»Ÿæ£€æµ‹ä¸­ï¼Œè¯·ç¨å€™...',
                    'ä¿®å¤å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•': 'ç»´æŠ¤è¿›è¡Œä¸­ï¼Œè¯·ç¨åå†è¯•'
                };
                
                const disguisedMessage = disguisedMessages[message] || message;
                statusEl.textContent = disguisedMessage;
            }
        }
        
        /**
         * ç”Ÿæˆè®¿é—®Token
         * é˜²æ­¢ç›´æ¥è®¿é—®ä¸­è½¬åŸŸå
         */
        function generateAccessToken() {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substring(2, 15);
            const secretKey = 'REDIRECT_SECRET_2025';
            
            // Generate signature
            const data = timestamp + random + secretKey;
            
            // Simple hash algorithm
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                const char = data.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            
            const signature = Math.abs(hash).toString(36);
            
            // Token format: timestamp.random.signature
            const token = timestamp + '.' + random + '.' + signature;
            
            console.log('[Token] Generated:', token);
            
            return token;
        }
        
        async function performRedirect() {
            try {
                const currentUrl = window.location.href;
                const urlObj = new URL(currentUrl);
                const params = urlObj.search; 
                
                if (!params || params.length <= 1) {
                    updateStatus('ç¼ºå°‘å¿…è¦å‚æ•°ï¼Œè¯·ä½¿ç”¨æœ‰æ•ˆé“¾æ¥è®¿é—®');
                    console.warn('[è­¦å‘Š] ç¼ºå°‘URLå‚æ•°');
                    return;
                }
                
                updateStatus(USE_API ? 'æ­£åœ¨è·å–åŸŸååˆ—è¡¨...' : 'æ­£åœ¨è·³è½¬...');
                const domains = await getDomains();
                
                if (!domains || domains.length === 0) {
                    throw new Error('æ²¡æœ‰å¯ç”¨çš„åŸŸå');
                }
                
                console.log('[åˆ—è¡¨] å¯ç”¨åŸŸååˆ—è¡¨:', domains);
                console.log('[æ¨¡å¼] å·¥ä½œæ¨¡å¼:', USE_API ? 'APIåŠ¨æ€æ¨¡å¼' : 'é™æ€æ¨¡å¼');
                
                const targetDomain = getRandomDomain(domains);
                
                let redirectUrl = targetDomain;
                
                if (params) {
                    redirectUrl += params;
                }
                
                // ç”Ÿæˆå¹¶æ·»åŠ Tokenåˆ°URL
                const token = generateAccessToken();
                const separator = redirectUrl.includes('?') ? '&' : '?';
                redirectUrl += separator + 'token=' + encodeURIComponent(token);
                
                console.log('[è·³è½¬] ä¸»åŸŸåè·³è½¬åˆ°ä¸­è½¬åŸŸå');
                console.log('[è·³è½¬] ä¸­è½¬åŸŸå:', targetDomain);
                console.log('[è·³è½¬] å‚æ•°:', params);
                console.log('[è·³è½¬] Token:', token);
                console.log('[è·³è½¬] å®Œæ•´URL:', redirectUrl);
                
                updateStatus('æ­£åœ¨è·³è½¬...');
                
                const randomDelay = getRandomDelay();
                console.log('[å»¶è¿Ÿ] éšæœºå»¶è¿Ÿ:', randomDelay + 'ms');
                
                setTimeout(() => {
                    window.location.replace(redirectUrl);
                }, randomDelay);
                
            } catch (e) {
                console.error('[é”™è¯¯] ä¿®å¤å¤±è´¥:', e);
                
                if (retryCount < CONFIG.MAX_RETRY) {
                    retryCount++;
                    updateStatus('ä¿®å¤å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•... (' + retryCount + '/' + CONFIG.MAX_RETRY + ')');
                    setTimeout(performRedirect, CONFIG.RETRY_DELAY);
                } else {
                    updateStatus('ä¿®å¤å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                }
            }
        }
        
        function detectEnvironment() {
            const ua = navigator.userAgent.toLowerCase();
            return {
                isWeChat: /micromessenger/i.test(ua),
                isQQ: /qq\//i.test(ua),
                isWeibo: /weibo/i.test(ua),
                isMobile: /mobile|android|iphone|ipad/i.test(ua),
                isBot: /bot|crawler|spider|scraper/i.test(ua)
            };
        }
        
        function antiCrawler() {
            const env = detectEnvironment();
            
            if (env.isBot) {
                console.warn('[è­¦å‘Š] æ£€æµ‹åˆ°çˆ¬è™«è®¿é—®');
            }
            
            if (window.innerWidth === 0 || window.innerHeight === 0) {
                console.warn('[è­¦å‘Š] å¼‚å¸¸çª—å£å¤§å°');
            }
            
            let mouseDetected = false;
            const mouseHandler = () => {
                mouseDetected = true;
                document.removeEventListener('mousemove', mouseHandler);
            };
            document.addEventListener('mousemove', mouseHandler);
            
            setTimeout(() => {
                if (!mouseDetected && env.isMobile === false) {
                    console.warn('[è­¦å‘Š] æœªæ£€æµ‹åˆ°é¼ æ ‡æ´»åŠ¨');
                }
            }, 2000);
        }
        
        function antiDebug() {
            const devtools = /./;
            devtools.toString = function() { 
                this.opened = true; 
            };
            
            setInterval(() => {
                console.log('%c', devtools);
                if (devtools.opened) {
                    console.clear();
                    // devtools.opened = false;
                }
            }, 1000);
            
            setInterval(() => {
                const start = performance.now();
                debugger;
                const end = performance.now();
                if (end - start > 100) {
                    console.clear();
                }
            }, 2000);
            
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('keydown', e => {
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && ['I', 'J', 'C'].includes(e.key)) ||
                    (e.ctrlKey && e.key === 'U')) {
                    e.preventDefault();
                }
            });
        }
        
        function getRandomDelay() {
            return RandomEngine.int(1000, 3000);
        }
        
        function checkAccessFrequency() {
            const storageKey = 'last_access_time';
            const minInterval = 1000; // æœ€å°é—´éš”1ç§’
            
            const lastTime = localStorage.getItem(storageKey);
            const now = Date.now();
            
            if (lastTime) {
                const interval = now - parseInt(lastTime);
                if (interval < minInterval) {
                    console.warn('[è­¦å‘Š] è®¿é—®é¢‘ç‡è¿‡é«˜');
                    return false;
                }
            }
            
            localStorage.setItem(storageKey, now.toString());
            return true;
        }
        
        function validateUserAgent() {
            const ua = navigator.userAgent;
            
            if (!ua || ua.length < 20) {
                console.warn('[è­¦å‘Š] å¯ç–‘çš„User-Agent');
                return false;
            }
            
            const validPatterns = [
                /Mozilla/,
                /Chrome|Safari|Firefox|Edge/,
                /Windows|Mac|Linux|Android|iOS/
            ];
            
            const isValid = validPatterns.some(pattern => pattern.test(ua));
            if (!isValid) {
                console.warn('[è­¦å‘Š] ä¸å¸¸è§çš„User-Agent');
            }
            
            return isValid;
        }
        
        antiCrawler();
        // antiDebug(); // å·²ç¦ç”¨ï¼Œé¿å…ç¼–ç é—®é¢˜
        checkAccessFrequency();
        validateUserAgent();
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', performRedirect);
        } else {
            performRedirect();
        }
    </script>
</body>
</html>
